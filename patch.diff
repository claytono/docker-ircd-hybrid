diff --git a/include/memory.h b/include/memory.h
index daadcfc..b044899 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -46,47 +46,5 @@ extern void *MyRealloc(void *x, size_t y);
 extern void MyFree(void *x);
 extern void _DupString(char **x, const char *y);
 
-/* forte (and maybe others) don't like double declarations, 
- * so we don't declare the inlines unless GNUC
- */
-#ifdef __GNUC__
-extern inline void *
-MyMalloc(size_t size)
-{
-  void *ret = calloc(1, size);
-
-  if (ret == NULL)
-    outofmemory();
-  return(ret);
-}
-
-extern inline void *
-MyRealloc(void *x, size_t y)
-{
-  void *ret = realloc(x, y);
-
-  if (ret == NULL)
-    outofmemory();
-  return(ret);    
-}
-
-extern inline void
-MyFree(void *x)
-{
-  if (x != NULL)
-    free(x);
-}
-
-extern inline void
-_DupString(char **x, const char *y)
-{
-  (*x) = malloc(strlen(y) + 1);
-
-  if (x == NULL)
-    outofmemory();
-  strcpy((*x), y); 
-}
-#endif /* __GNUC__ */
-
 #define DupString(x,y) _DupString(&x, y)
 #endif /* _I_MEMORY_H */
diff --git a/include/tools.h b/include/tools.h
index 8420600..5b0d2e6 100644
--- a/include/tools.h
+++ b/include/tools.h
@@ -83,183 +83,4 @@ void mem_frob(void *data, int len);
 /* Returns the list length */
 #define dlink_list_length(list) (list)->length
 
-/*
- * The functions below are included for the sake of inlining
- * hopefully this will speed up things just a bit
- * 
- */
-/* forte (and maybe others) dont like these being declared twice,
- * so we dont declare the inlines unless GNUC.
- */
-#ifdef __GNUC__
-
-/* 
- * dlink_ routines are stolen from squid, except for dlinkAddBefore,
- * which is mine.
- *   -- adrian
- */
-extern inline void
-dlinkAdd(void *data, dlink_node * m, dlink_list * list)
-{
- m->data = data;
- m->prev = NULL;
- m->next = list->head;
- /* Assumption: If list->tail != NULL, list->head != NULL */
- if (list->head != NULL)
-   list->head->prev = m;
- else if (list->tail == NULL)
-   list->tail = m;
- list->head = m;
- list->length++;
-}
-
-extern inline void
-dlinkAddBefore(dlink_node *b, void *data, dlink_node *m, dlink_list *list)
-{
-    /* Shortcut - if its the first one, call dlinkAdd only */
-    if (b == list->head)
-        dlinkAdd(data, m, list);
-    else {
-        m->data = data;
-        b->prev->next = m;
-        m->prev = b->prev;
-        b->prev = m; 
-        m->next = b;
-	list->length++;
-    }
-}
-
-extern inline void
-dlinkAddTail(void *data, dlink_node *m, dlink_list *list)
-{
- m->data = data;
- m->next = NULL;
- m->prev = list->tail;
- /* Assumption: If list->tail != NULL, list->head != NULL */
- if (list->tail != NULL)
-   list->tail->next = m;
- else if (list->head == NULL)
-   list->head = m;
- list->tail = m;
- list->length++;
-}
-
-/* Execution profiles show that this function is called the most
- * often of all non-spontaneous functions. So it had better be
- * efficient. */
-extern inline void
-dlinkDelete(dlink_node *m, dlink_list *list)
-{
- /* Assumption: If m->next == NULL, then list->tail == m
-  *      and:   If m->prev == NULL, then list->head == m
-  */
- if (m->next)
-   m->next->prev = m->prev;
- else {
-   assert(list->tail == m);
-   list->tail = m->prev;
- }
- if (m->prev)
-   m->prev->next = m->next;
- else {
-   assert(list->head == m);
-   list->head = m->next;
- }
- /* Set this to NULL does matter */
- m->next = m->prev = NULL;
-  list->length--;
-}
-
-/*
- * dlinkFind
- * inputs	- list to search 
- *		- data
- * output	- pointer to link or NULL if not found
- * side effects	- Look for ptr in the linked listed pointed to by link.
- */
-extern inline dlink_node *
-dlinkFind(dlink_list *list, void *data)
-{
-  dlink_node *ptr;
-
-  DLINK_FOREACH(ptr, list->head)
-  {
-    if (ptr->data == data)
-      return(ptr);
-  }
-
-  return(NULL);
-}
-
-extern inline void
-dlinkMoveList(dlink_list *from, dlink_list *to)
-{
-  /* There are three cases */
-  /* case one, nothing in from list */
-
-    if (from->head == NULL)
-      return;
-
-  /* case two, nothing in to list */
-  /* actually if to->head is NULL and to->tail isn't, thats a bug */
-
-    if (to->head == NULL)
-    {
-       to->head = from->head;
-       to->tail = from->tail;
-       from->head = from->tail = NULL;
-       to->length = from->length;
-       from->length = 0;
-       return;
-    }
-
-  /* third case play with the links */
-
-    from->tail->next = to->head;
-    from->head->prev = to->head->prev;
-    to->head->prev = from->tail;
-    to->head = from->head;
-    from->head = from->tail = NULL;
-    to->length += from->length;
-    from->length = 0;
-
-  /* I think I got that right */
-}
-
-extern inline dlink_node *
-dlinkFindDelete(dlink_list *list, void *data)
-{
-  dlink_node *m;
-
-  DLINK_FOREACH(m, list->head)
-  {
-    if (m->data == data)
-    {
-      if (m->next)
-        m->next->prev = m->prev;
-      else
-      {
-        assert(list->tail == m);
-        list->tail = m->prev;
-      }
-      if (m->prev)
-        m->prev->next = m->next;
-      else
-      {
-        assert(list->head == m);
-        list->head = m->next;
-      }
-      /* Set this to NULL does matter */
-      m->next = m->prev = NULL;
-      list->length--;
-
-      return(m);
-    }
-  }
-
-  return(NULL);
-}
-
-#endif /* __GNUC__ */
-
 #endif /* __TOOLS_H__ */
diff --git a/src/s_bsd_sigio.c b/src/s_bsd_sigio.c
index 02a850d..5bba6cc 100644
--- a/src/s_bsd_sigio.c
+++ b/src/s_bsd_sigio.c
@@ -217,7 +217,7 @@ comm_select(void)
 {
   static time_t last_rtsigqo_warning = 0;
   struct timespec timeout;
-  struct siginfo si;
+  siginfo_t si;
   int i, revents, num;
   fde_t *F;
   PF *hdl;
